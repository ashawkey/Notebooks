# 二分法



### 应用二分法的前提条件

**搜索空间单调！**
$$
i < j \Rightarrow test(i) \rightarrow test(j)
$$

```c++
int l = 0;
int r = v.size();

// [l, r] form, search for left bound
while (l <= r) {
    int m = l + (r - l) / 2;
    if (test(m)) {
        r = m - 1;
    }
    else {
        l = m + 1;
    }
}

return l;
```





### 分类（根据搜索目标）

* 单值

  ```c++
  int binary_search(int[] nums, int target) {
      int left = 0, right = nums.length - 1; 
      while(left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1; 
          } else if(nums[mid] == target) {
              // 直接返回
              return mid;
          }
      }
      // 直接返回
      return -1;
  }
  ```

  

* 左边界

  ```c++
  int left_bound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1;
          } else if (nums[mid] == target) {
              // 别返回，锁定左侧边界
              right = mid - 1;
          }
      }
      // 最后要检查 left 越界的情况
      if (left >= nums.length || nums[left] != target)
          return -1;
      return left;
  }
  ```

  

* 右边界

  ```c++
  int right_bound(int[] nums, int target) {
      int left = 0, right = nums.length - 1;
      while (left <= right) {
          int mid = left + (right - left) / 2;
          if (nums[mid] < target) {
              left = mid + 1;
          } else if (nums[mid] > target) {
              right = mid - 1;
          } else if (nums[mid] == target) {
              // 别返回，锁定右侧边界
              left = mid + 1;
          }
      }
      // 最后要检查 right 越界的情况
      if (right < 0 || nums[right] != target)
          return -1;
      return right;
  }
  ```

  

### 题目

##### [174 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

正向动态规划不现实，需要记录抵达时最大生命与途中最小生命，不满足最优子结构。

但是在给定生命时，可以通过正向动态规划得到抵达时的最大生命。

存活是生命的单调函数，问题转变为对左边界（最小需要生命）的二分搜索。

从`+inf`开始搜索，问题保证有解，故不需要越界检查。

```c++
class Solution {
public:
    bool test(vector<vector<int>>& dungeon, int m) {
        int M = dungeon.size();
        int N = dungeon[0].size();
        vector<vector<int>> dp(M + 1, vector<int>(N + 1, -0x3f3f3f));
        dp[0][1] = dp[1][0] = m;
        for (int i = 1; i <= M; i++) {
            for (int j = 1; j <= N; j++) {
                int val = max(dp[i-1][j], dp[i][j-1]) + dungeon[i-1][j-1];
                if (val <= 0) continue;
                else dp[i][j] = val;
            }
        }
        return dp[M][N] > 0;
    }
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        // [l, r] binary search, left bound
        int l = 1, r = 0x3f3f3f3f;
        while (l <= r) {
            int m = l + (r - l) / 2;
            // m survives
            if (test(dungeon, m)) r = m - 1;
            else l = m + 1;
        }
        return l;
    }
};
```

##### [162寻找峰值](https://leetcode-cn.com/problems/find-peak-element/)

边界判定十分麻烦。

```c++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        // size == 1
        if (nums.size() == 1) return 0;
        int l = 0, r = nums.size() - 1;
        while (l <= r) {
            int m = l + (r - l) / 2;
			// border
            if (m == 0) return nums[m] > nums[m + 1] ? m : m + 1;
            if (m == nums.size() - 1) return nums[m] > nums[m - 1] ? m : m - 1;
            // middle
            if (nums[m] > nums[m - 1] && nums[m] > nums[m + 1]) return m;
            else if (nums[m] <= nums[m - 1]) r = m - 1;
            else if (nums[m] <= nums[m + 1]) l = m + 1;
        }
        return -1; // never reach here.
    }
};
```
