# Common sense

* `1e9+7`

  A large prime, usually used as the modulo.

* `0x3f3f3f3f`

  usually used as `+inf int` .

  ```c++
  // binary search
  int l = 0, r = 0x3f3f3f3f;
  
  // dp memset
  memset(dp, 0x3f, sizeof(dp));
  ```

* leetcode errors

  * Index out of bounds

    ```
    AddressSanitizer: heap-buffer-overflow 
    AddressSanitizer: stack-buffer-overflow
    AddressSanitizer: global-buffer-overflow 
    ```

  * access a deleted array

    ```
    AddressSanitizer: heap-use-after-free
    ```

* c++ solution template

  ```c++
  #include <iostream>
  #include <cstring>
  #include <cmath>
  #include <algorithm>
  #include <climits>
  #include <stack>
  #include <queue>
  #include <vector>
  #include <set>
  #include <map>
  #include <list>
  #include <cassert>
  #include <unordered_map>
  
  #define DEBUG false
  
  #define $(x) {if (DEBUG) {cout << __LINE__ << ": "; {x} cout << endl;}}
  #define _(x) {cout << #x << " = " << x << " ";}
  
  const double E = 1e-8;
  const double PI = acos(-1);
  
  using namespace std;
  
  int main() {
      ios::sync_with_stdio(false);
      
  }
  ```

  

* fast power

  ```c++
  // pow(n, p) % M, p >= 0
  
  // int / long long version
  int power_modulo(int n, int p, int M) {
      int res = 1;
      while (p > 0) {
          if (p % 2 == 1) res = (res * n) % M;
          p /= 2;
          n = (n * n) % M;
      }
      return res;
  }
  
  // double version
  double power(double n, long long p) {
      double res = 1;
      while (p > 0) {
          if (p % 2 == 1) ans *= n;
          p /= 2;
          n *= n;
      }
      return res;
  }
  ```

  

* Fibonacci

  ```c++
  // O(logN)
  int fib(int n) {
      if (n <= 1) return 1;
      vector<vector<int>> a = {{1, 1}, {1, 0}};
      a = matpow(a, n - 2);
      return a[0][0] + a[0][1];
  }
  
  vector<vector<int>> matpow(vector<vector<int>> a, int p) {
      vector<vector<int>> ans = {{1, 0}, {0, 1}}; // I
      while (p) {
          if (p % 2) ans = matmul(ans, a);
          p /= 2;
          a = matmul(a, a);
      }
      return ans;
  }
  
  vector<vector<int>> matmul(vector<vector<int>> a, vector<vector<int>> b) {
  	vector<vector<int>> res(2, vector<int>(2, 0));
  	res[0][0] = a[0][0] * b[0][0] + a[0][1] * b[1][0];
     	res[0][1] = a[0][0] * b[0][1] + a[0][1] * b[1][1];
     	res[1][0] = a[1][0] * b[0][0] + a[1][1] * b[1][0];
   	res[1][1] = a[1][0] * b[0][1] + a[1][1] * b[1][1];
      return res;
  }
  
  // Binet formula, O(1)
  int fib(int n) {
      double r = (1 + sqrt(5)) / 2; // 0.618
      int ans = (int)round(pow(r, n) / sqrt(5)); // rounded results!
      return ans;
  }
  ```

* Bit operator

  ```c++
  #define GET_BIT(n, i) (((n) & (1LL << ((i)-1))) >> ((i)-1)) // i start from 1
  #define SET_BIT(n, i) ((n) | (1LL << ((i)-1)))
  #define CLR_BIT(n, i) ((n) & ~(1LL << ((i)-1)))
  
  // display in binary
  #include <bitset>
  void show_binary(unsigned long long x) {
  	printf("%s\n", bitset<64>(x).to_string().c_str());
  }
  
  // interesting results
  ('a' | ' ') == 'a';
  ('A' | ' ') == 'a';
  ('b' & '_') == 'B';
  ('B' & '_') == 'B';
  ('d' ^ ' ') == 'D';
  ('D' ^ ' ') == 'd';
  
  // eliminate last 1 in binary format
  n = n & (n - 1);
  bool isPowerOfTwo(int n) {
      if (n <= 0) return false;
      return (n & (n - 1)) == 0;
  }
  
  // 只出现一次的元素
  int singleNumber(vector<int>& nums) {
      int res = 0;
      for (int n : nums) {
          res ^= n;
      }
      return res;
  }
  ```

  

* GCD/LCM

  ```c++
  int gcd(int a, int b) {
      return b == 0 ? a : gcd(b, a % b);
  }
  
  int lcm(int a, int b) {
      if (gcd(a,b)>0) {
          return (a / gcd(a, b)) * b;
      }
      return 0;
  }
  ```



* is prime

  ```c++
  bool is_prime(int n) {
      if (n <= 1) return false;
      if (n == 2) return true;
      for (int i = 2; i < sqrt(n) + 1; i++) {
          if (n % i == 0) return false;
      }
      return true;
  }
  
  // A prime number greater than 3 can be written in the form 6n - 1 or 6n + 1 
  // This is of the order O(sqrt(n))  with reduced leading constant
  bool is_prime(int n) {
      if (n == 1 || n % 2 == 0) return false;  
      if (n == 2 || n == 3) return true;
      int t = sqrt(n);
      int k = t / 6;
      for (int i = 1; i <= k; i++) {
      	if((n%(6*t - 1)==0) || (n%(6*t + 1)==0)) return false;
      }
      return true;
  }
  
  // prime table
  int is_prime[UP_LIMIT + 1];
  for (int i = 1; i <= UP_LIMIT; i++) // init to 1
      is_prime[i] = 1;
  for (int i = 4; i <= UP_LIMIT; i += 2) // even number is not
      is_prime[i] = 0;
  for (int k = 3; k*k <= UP_LIMIT; k++) // start from 9, end at sqrt
      if (is_prime[k])
          for(int i = k*k; i <= UP_LIMIT; i += 2*k) // every two is not 
              is_prime[i] = 0;
  ```

  