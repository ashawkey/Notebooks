# 二分法

```c++
/* [,) format binary search */
// same as std::lower_bound
class Solution {
public:
    // right = nums.size(); 
    // if target is larger than all nums, return **N**
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that equals target
        // or the first place that is large than target if can't find target.
        // since left may be N, check the bourdary first.
        if(left >= nums.size() || nums[left] != target) return -1; 
        else return left;
    }
    
    // right = nums.size()-1; USE THIS !
    // if target is larger than all nums, return **N-1**
    // if target is smaller than all nums, return **0**
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that equals target
        // or the first place that is large than target if can't find target.
        if(nums[left] != target) return -1; 
        else return left;
    }
};


// upper_bound, only one modification
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that is large than target.
        // if target doesn't exist, the same.
        else return left;
    }
};


// [,] format search.
int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size(); // or nums.size()-1; it's the same.
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target) return mid;
        else if(nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    // if not found, left is the first place that is larger than target.
    return -1;
}

// examples
/* find the minimal value that is good.
assume isgood(int) is incremental. */
int l = mn, r = mx;
while(l<=r){
    int m = (l+r)/2;
    if(isgood(m)) r = m-1;
    else l = m+1;
}
cout<<l<<endl;
```

### Examples

* Search in Rotated sorted array (leetcode 33)

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          // find pivot
          int l=0, r=nums.size()-1;
          while(l<r){
              int m = l + (r - l) / 2;
              if(nums[m] > nums[r]) l = m + 1;
              else r = m;
          }
          // normal binary search
          int idx;
          idx = lower_bound(nums.begin(), nums.begin()+l, target) - nums.begin();
          if(idx < l && nums[idx] == target) return idx;
          idx = lower_bound(nums.begin()+l, nums.end(), target) - (nums.begin()+l);
          if(l+idx < nums.size() && nums[l+idx] == target) return idx+l;
          return -1;
      }
  };
  ```

* Search in Duplicated & Rotated sorted array (leetcode 154)

  ```c++
  class Solution {
  public:
      int findMin(vector<int>& nums) {
          int N = nums.size();
          if(!N) return false;
  		
          // find pivot
          int l=0, r=N-1;
          while(l<r){
              int m = l+(r-l)/2;
              if(nums[l] == nums[r]) l++; // remove duplication
              else if(nums[m] > nums[r]) l = m+1;
              else r = m;
          }
          
          return min(nums[0], nums[l]);
      }
  };
  ```

* Find Peak Element (leetcode 162)

  还能这么用！

  ```c++
  class Solution {
  public:
      int findPeakElement(vector<int>& nums) {
          int l=0, r=nums.size()-1;
          while(l<r){
              int m = (l+r)/2;
              if(nums[m] < nums[m+1]) l = m + 1;
              else r = m;
          }
          return l;
      }
  };
  ```

* Use `std` correctly, especially when not found.

  leetcode 34.

  ```c++
  class Solution {
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          if(nums.empty()) return vector<int>(2, -1);
          vector<int> ans;
          int a = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
          int b = upper_bound(nums.begin(), nums.end(), target) - nums.begin();
          cout<<a<<" "<<b<<endl;
          // not found exception
          if(a>=nums.size() || nums[a] != target) ans.push_back(-1);
          else ans.push_back(a);
          if(b-1>=nums.size() || nums[b-1] != target) ans.push_back(-1);
          else ans.push_back(b-1);
          return ans;
      }
  };
  ```

* Split Array Largest Sum leetcode 410

  二分鬼题。二分太强大了，就是不知道该什么时候用。

  ```c++
  class Solution {
  public:
      #define ll long long
      bool check(vector<int>& nums, ll mid, int m){
          int cnt = 0;
          ll sum = 0;
          for(int i=0; i<nums.size(); i++){
              sum += nums[i];
              if(sum > mid){
                  sum = nums[i];
                  cnt++;
                  if(cnt >= m) return true;
              }
          }
          return false;
      }
      
      int splitArray(vector<int>& nums, int m) {
          ll sum=0;
          int mx = 0;
          for(int i=0; i<nums.size(); i++){
              sum += nums[i];
              mx = max(mx, nums[i]);
          }
          ll left = mx, right = sum;
          while(left<right){
              ll mid = (left + right) / 2;
              if(check(nums, mid, m)) left = mid + 1;
              else right = mid;
          }
          return int(left);
          
      }
  };
  ```

* 寻找最近数

  很迷。lower_bound不对，upper_bound要检验idx==end时减一，还要和idx-1比较一些谁更近。

  ```python
  T = int(input())
  
  data = input()
  S = [int(ele) for ele in data.split()]
  
  def solve(S, T):
      S.sort()
      i = 0
      j = len(S) - 1
      res = S[i] + S[j]
      while i < j:
          cur_val = S[i] + S[j]
          if abs(cur_val - T) < abs(res - T) or abs(cur_val - T) == abs(res - T) and cur_val < res:
              res = cur_val
          if cur_val == T:
              break
          elif cur_val < T:
              i = i + 1
          else:
              j = j - 1
      return res
  print(solve(S, T))
  ```
