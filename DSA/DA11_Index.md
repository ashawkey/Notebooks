# Index

索引是一种数据结构，支持高效检索&动态调整（数据库技术）。

* 主码（Primary Key）：每条记录的**唯一**标识。

* 辅码：可重复的属性

* 索引：把关键码与它对应的记录未知关联起来的过程（关键码，指针）

  * 稠密索引：每个记录建立一个索引项。

    主文件无需按照关键码排序。

  * 稀疏索引：一组记录建立一个索引项。

    主文件必须按照关键码次序存放。

    可以把记录分块，索引指针指向每块的起始位置。

* 索引文件：记录这种联系的文件。

* 主文件：原始数据记录

  一个主文件可能有多个相关索引文件，每个索引文件支持一个索引字段。



### 线性检索

按照索引码值的顺序进行排序的文件。

* 特点

  可以访问变长数据库记录，支持高效二分检索。

  体积太大，只能存储在磁盘中，影响效率。

* **二级线性索引**

  一个磁盘可以存放M个记录。

  原始数据有N个记录，一级索引也有N个记录，则一级索引占用$N/M$个磁盘块。

  再对一级索引按照磁盘块建立二级索引，只需要$N/M^2$个磁盘块。

  每个二级索引存放对应的一级索引块中的第一个索引。

  检索过程使用两次二分搜索即可。



### 静态检索(Deprecated)

文件创建完成时索引就不能再被修改了。



### 倒排检索

由属性值来确定记录的位置，称为倒排检索（基于属性/基于正文）。

* 基于属性的倒排

  倒排表：`(attr, ptrList)`

  ​	属性（不唯一） `-->` 若干记录指针（唯一，如关键码或主文件地址）

  ​	可以对不同属性建立多个倒排表。

  优点：基于属性的高效检索。

  缺点：倒排表空间代价，更新运算效率降低。

* 对正文文件的倒排

  支持文本内容的快速检索

  * 词索引

    提取关键词（过滤停用词），对关键词建立倒排表：

    `(keyword, [(text, position), ...])`

    检索时，首先检索关键词，之后提取关键词对应的记录指针列表，获取记录。

    通常用另一个索引结构对关键词进行检索，如Trie图，散列。

  * 全文索引

  优点：高效检索文本数据库。

  缺点：支持的检索类型有限，检索词有限，空间代价极高。



### 动态检索

动态更新删除，并保持最佳检索性能。

#### B树

* 定义

  m阶B树为m路平衡查找树，或者为空，或者：

  * 每个节点至多m个子树（m-1个关键码）
  * 根节点至少2个子树，其他非叶节点至少`ceil(m/2)`个子树

* **节点的一般形态  **

  ```
  [ P0 K1 P1 K2 P2 ... P(j-1) Kj Pj ]
  ```

  包含j个递增关键码K，j+1个指向两个关键码之间的子节点的指针。

* 性质

  - 有k个子树（指针P）的节点有k-1个关键码K
  - 树高平衡，叶节点位于同一层，关键码不重复
  - 父节点关键码是子节点的分界
  - 访问局部性原理：值相近的记录放在相近的磁盘页中。
  - 节点关键码至少一定比例是满的（保持效率）

* 查找

  * 两步交替

    * 读取根节点，在其K个关键码中（二分）检索目标关键码T。找到则检索结束。
    * 否则，T落在两个K之间，取对应的P子树继续检索。如果P为空指针，检索失败。

  * 检索长度

    H为树高，则最多H+1次访外。

* 插入

  保持**等高（尽量）、等阶**的性质。

  找到最底层合适位置插入，溢出则节点分裂为左右两个节点，中间关键码连同新指针提升进入父节点，直到不溢出（根节点也溢出时，树高增加一层）。

  节点分裂：插入后若节点数为m（溢出），则

  ```
  [K1 K2 ... Km] -> [K1 ... K(ceil(m/2)-1)] + 
  				  [K(ceil(m/2))] + 
  				  [K(ceil(m/2)+1) ... Km]
  ```

* 删除

  * 叶节点

    * 删除后节点数不小于ceil(m/2)-1：直接删除

    * 删除后节点数小于ceil(m/2)-1

      * 相邻兄弟节点关键码大于ceil(m/2)-1

        借若干关键码，调整父节点分界

      * 相邻兄弟节点关键码等于ceil(m/2)-1

        合并两个节点，并把父节点分界拉下来（有可能使树高减一）。

  * 非叶节点

    把此关键码与后继兑换位置，成为叶节点再删除。

* 性能分析

  对于m阶k层的B树，N个关键码的B树有N+1个外部空指针。
  $$
  N+1 \ge 2*\lceil \frac m 2 \rceil^{k-1} \\
  k \le 1 + log_{\lceil m/2 \rceil}(\frac {N+1} 2) \\
  $$
  k也是每次查找时最多访外次数。

  设p为内部节点数，s为每插入一个关键码的平均分裂节点数：
  $$
  s = \frac{p-1}{N-1} \le \frac 1 {\lceil m/2 \rceil - 1}
  $$



#### B+树

B树变体，**只在叶节点存储信息。**

* 定义

  m阶B+树或者为空，或者：

  * 每个节点至多m个子节点
  * 根节点至少2个子节点，非根节点至少`ceil(m/2)`个子节点，

* 性质

  * 有k个子节点的节点有k个关键码

    ```bash
    [K1 P1 ... Km Pm]
    ```

    每个Pi指针指向一个子节点，对应的Ki为子节点中关键码的最大值（或最小值）。

  * 叶节点一般用双链表连接起来

* 查找

  读取根节点，二分检索范围，取对应子树继续查找。

  直到查找到叶节点层。

* 插入

  * 分裂：

    ```bash
    [K0 ... Km] --> [K0 ... K(floor(m/2))] + 
    				[K(ceil(m/2)) ... Km]
    ```

* 删除

  * 删除关键码后个数小于`ceil(m/2)`




### 红黑树

* 定义

  满足如下约束的BST树：

  * 黑红二色：每个节点被染色为红色或黑色。
  * 首尾皆黑：根节点与叶节点均为黑色。
  * 红红不连：红色节点不相连。
  * 黑点同阶：任意节点到其叶节点的路径包含相同数目的黑色节点。

  **节点X的阶**（黑色高度，Rank）：该节点到对应子树的任一外部节点的路径上黑色节点的个数。不包括自身，包括叶节点。叶节点阶0，根节点的阶称为树的阶。

* 性质

  * 满二叉树**（树叶均为黑色NULL）**

  * k阶红黑树根到叶的简单路径长度介于`[k, 2k]`间

    均为黑节点最短，黑红相间最长。

  * 内部节点数最少是完全满二叉树，即$2^k-1$

  * n个内部节点红黑树的最大高度：$2log_2(n+1)+1$

    设阶为k，树高为h。
    $$
    h \le 2k+1 \\
    n \ge 2^k - 1 \\
    \Rightarrow h\le 2log_2(n+1)+1
    $$

* 插入

  新插入的节点X标记为红色。父节点黑色则结束，否则进行**双红调整**：

  * 红黑旋转：X的叔节点黑色或NULL

    以祖父为轴，旋转父节点。

  * 红红换色：X的叔节点红色

    父祖换色，父叔变黑，对祖节点继续红红递归检查。

    若祖节点是根则仅将父叔换色。

* 删除

  待删节点没有空树叶，先与**右子树最小的后继结点**交换（换值不换色），再删除该后继。

  待删节点有一个空树叶：删除后把非空子树的根替换到此处且变黑（该根一定为红色）。

  待删节点有两个空树叶：

  * 待删节点红色，直接删除。

  * 待删节点黑色，**双黑调整**（直接删除会使阶失衡）：

    * 双黑节点X兄第是红色，则旋转。

      父节点一定黑，兄弟的子节点也均黑。

      若X仍为双黑节点，则转换为以下两种情况之一：

    * 双黑节点X兄第是黑色，且有两个黑子节点。

      父兄换色，兄弟变红，父亲变黑。

      若父亲原来是红色，则调整结束。否则对父节点再进行双黑调整。

    * 双黑节点X兄第是黑色，且子节点有红色（红黑或红红）。

      侄子红节点在右（八字外撇）：旋转

      侄子红节点在左（同边顺）：旋转



* 性能分析

  平均和最差检索$O(lgn)$。

  统计性能优于AVL树。且增删算法相对简单。

  set，multiset，map，multimap均为红黑树变体。