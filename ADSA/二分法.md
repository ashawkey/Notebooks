# 二分法

```c++
/* [,) format binary search */
// same as std::lower_bound
class Solution {
public:
    // right = nums.size(); 
    // if target is larger than all nums, return **N**
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that equals target
        // or the first place that is large than target if can't find target.
        // since left may be N, check the bourdary first.
        if(left >= nums.size() || nums[left] != target) return -1; 
        else return left;
    }
    
    // right = nums.size()-1; USE THIS !
    // if target is larger than all nums, return **N-1**
    // if target is smaller than all nums, return **0**
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size()-1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that equals target
        // or the first place that is large than target if can't find target.
        if(nums[left] != target) return -1; 
        else return left;
    }
};


// upper_bound, only one modification
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size();
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        // left is the first place that is large than target.
        // if target doesn't exist, the same.
        else return left;
    }
};


// [,] format search.
int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size(); // or nums.size()-1; it's the same.
    while(left <= right){
        int mid = left + (right - left)/2;
        if(nums[mid] == target) return mid;
        else if(nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    // if not found, left is the first place that is larger than target.
    return -1;
}

// examples
/* find the minimal value that is good.
assume isgood(int) is incremental. */
int l = mn, r = mx;
while(l<=r){
    int m = (l+r)/2;
    if(isgood(m)) r = m-1;
    else l = m+1;
}
cout<<l<<endl;
```

### Examples

* Search in Rotated sorted array (leetcode 33)

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          // find pivot
          int l=0, r=nums.size()-1;
          while(l<r){
              int m = l + (r - l) / 2;
              if(nums[m] > nums[r]) l = m + 1;
              else r = m;
          }
          // normal binary search
          int idx;
          idx = lower_bound(nums.begin(), nums.begin()+l, target) - nums.begin();
          if(idx < l && nums[idx] == target) return idx;
          idx = lower_bound(nums.begin()+l, nums.end(), target) - (nums.begin()+l);
          if(l+idx < nums.size() && nums[l+idx] == target) return idx+l;
          return -1;
      }
  };
  ```

* Search in Duplicated & Rotated sorted array (leetcode 154)

  ```c++
  class Solution {
  public:
      int findMin(vector<int>& nums) {
          int N = nums.size();
          if(!N) return false;
  		
          // find pivot
          int l=0, r=N-1;
          while(l<r){
              int m = l+(r-l)/2;
              if(nums[l] == nums[r]) l++; // remove duplication
              else if(nums[m] > nums[r]) l = m+1;
              else r = m;
          }
          
          return min(nums[0], nums[l]);
      }
  };
  ```

* Find Peak Element (leetcode 162)

  还能这么用。。。

  ```c++
  class Solution {
  public:
      int findPeakElement(vector<int>& nums) {
          int l=0, r=nums.size()-1;
          while(l<r){
              int m = (l+r)/2;
              if(nums[m] < nums[m+1]) l = m + 1;
              else r = m;
          }
          return l;
      }
  };
  ```

* Use `std` correctly, especially when not found.

  leetcode 34.

  ```c++
  class Solution {
  public:
      vector<int> searchRange(vector<int>& nums, int target) {
          if(nums.empty()) return vector<int>(2, -1);
          vector<int> ans;
          int a = lower_bound(nums.begin(), nums.end(), target) - nums.begin();
          int b = upper_bound(nums.begin(), nums.end(), target) - nums.begin();
          cout<<a<<" "<<b<<endl;
          // not found exception
          if(a>=nums.size() || nums[a] != target) ans.push_back(-1);
          else ans.push_back(a);
          if(b-1>=nums.size() || nums[b-1] != target) ans.push_back(-1);
          else ans.push_back(b-1);
          return ans;
      }
  };
  ```
