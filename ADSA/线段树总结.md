# Segment Tree 

### 区间最值替换模型

**替换**某个区间的最值为某个数。

而非增加到某个数（见下）。也不是取当前值与目标值的最大值（无法实现）。

区间最值也应该使用lazy更新，才能保证复杂度。pushdown操作即分解区间，把lazy标志（叶节点标志）下移一层。pushup即用子区间反推父区间的值。modify和query在分解子区间时都需要pushdown。modify最后还需要调用pushup。

```c++
const static int maxn = 10005;

struct node {
    int l, r;
    int mx, lazy;
    int m() { return (l + r) / 2; }
} seg[4 * maxn];

void build(int rt, int l, int r) {
    seg[rt].l = l;
    seg[rt].r = r;
    seg[rt].mx = 0;
    seg[rt].lazy = 0;
    if (l == r) return;
    build(2 * rt + 1, l, (l + r) / 2);
    build(2 * rt + 2, (l + r) / 2 + 1, r);
}

void pushup(int rt){
    seg[rt].mx = max(seg[2 * rt + 1].mx, seg[2 * rt + 2].mx);
}

void pushdown(int rt) {
    if (seg[rt].lazy) {
        //cout<<"push down "<<rt<<" "<< seg[rt].l << "-" << seg[rt].r << endl;
        seg[2 * rt + 1].mx = seg[rt].mx;
        seg[2 * rt + 2].mx = seg[rt].mx;
        seg[2 * rt + 2].lazy = seg[2 * rt + 1].lazy = 1;
        seg[rt].lazy = 0;
    }
}

int query(int rt, int l, int r) {
    //cout << "query " <<rt<<" "<< seg[rt].l << "-" << seg[rt].r << " " << l << "-" << r << endl;
    if (l == seg[rt].l && r == seg[rt].r)
        return seg[rt].mx;
    // push down
    pushdown(rt);
    int m = seg[rt].m();
    if (r <= m) return query(2 * rt + 1, l, r);
    else if (l > m) return query(2 * rt + 2, l, r);
    else return max(query(2 * rt + 1, l, m), query(2 * rt + 2, m + 1, r));
}

void modify(int rt, int l, int r, int v) {
    //cout << "modify " <<rt<<" "<< seg[rt].l << "-" << seg[rt].r << " " << l << "-" << r << " to " << v << endl;
    if (l == seg[rt].l && r == seg[rt].r) {
        seg[rt].mx = v; // set to v, not add v.
        seg[rt].lazy = 1;
        return;
    }
    // push down
    pushdown(rt);
    // interval decomp
    int m = seg[rt].m();
    if (r <= m) modify(2 * rt + 1, l, r, v);
    else if (l > m) modify(2 * rt + 2, l, r, v);
    else {
        modify(2 * rt + 1, l, m, v);
        modify(2 * rt + 2, m + 1, r, v);
    }
    // push up
    pushup(rt);
}
```



###### LeetCode 699 Falling Squares

```c++
class Solution {
public:
    const static int maxn = 10005;
    
    struct node {
        int l, r;
        int mx, lazy;
        int m() { return (l + r) / 2; }
    } seg[4 * maxn];

    void build(int rt, int l, int r) {
        seg[rt].l = l;
        seg[rt].r = r;
        seg[rt].mx = 0;
        seg[rt].lazy = 0;
        if (l == r) return;
        build(2 * rt + 1, l, (l + r) / 2);
        build(2 * rt + 2, (l + r) / 2 + 1, r);
    }

    void pushdown(int rt) {
        if (seg[rt].lazy) {
            seg[2 * rt + 1].mx = seg[rt].mx;
            seg[2 * rt + 2].mx = seg[rt].mx;
            seg[2 * rt + 2].lazy = seg[2 * rt + 1].lazy = 1;
            seg[rt].lazy = 0;
        }
    }

    int query(int rt, int l, int r) {
        if (l == seg[rt].l && r == seg[rt].r)
            return seg[rt].mx;
        // push down
        pushdown(rt);
        int m = seg[rt].m();
        if (r <= m) return query(2 * rt + 1, l, r);
        else if (l > m) return query(2 * rt + 2, l, r);
        else return max(query(2 * rt + 1, l, m), query(2 * rt + 2, m + 1, r));
    }

    void modify(int rt, int l, int r, int v) {
        if (l == seg[rt].l && r == seg[rt].r) {
            seg[rt].mx = v;
            seg[rt].lazy = 1;
            return;
        }
        // push down
        pushdown(rt);
        // interval decomp
        int m = seg[rt].m();
        if (r <= m) modify(2 * rt + 1, l, r, v);
        else if (l > m) modify(2 * rt + 2, l, r, v);
        else {
            modify(2 * rt + 1, l, m, v);
            modify(2 * rt + 2, m + 1, r, v);
        }
        // push up
        seg[rt].mx = max(seg[2 * rt + 1].mx, seg[2 * rt + 2].mx);
    }
	
    // 俄罗斯方块堆叠式的更新
    void blockmodify(int rt, int l, int r, int v) {
        modify(rt, l, r, v + query(rt, l, r));
    }

    
    vector<int> fallingSquares(vector<pair<int, int>>& positions) {
        // 离散化
        vector<int> xs;
        for(int i=0; i<positions.size(); i++){
            xs.push_back(positions[i].first);
            xs.push_back(positions[i].first + positions[i].second - 1);
        }
        sort(xs.begin(), xs.end());
        int uN = unique(xs.begin(), xs.end()) - xs.begin();
        map<int, int> m;
        for(int i=0; i<uN; i++) m[xs[i]]=i;
        // 线段树
        build(0, 0, uN);
        vector<int> ans;
        for(int i=0; i<positions.size(); i++){
            blockmodify(0,
                        m[positions[i].first],
                        m[positions[i].first + positions[i].second - 1],
                        positions[i].second
                       );
            ans.push_back(query(0, 0, uN));
        }
        return ans;
    }
};
```



### 区间求和模型

在求和的同时可以求最值。

